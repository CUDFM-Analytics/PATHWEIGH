# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Carlos Rodriguez, PhD. Dept. of Fam. Med. CU Anschutz Medical Campus
# 02/02/2024
# Get labs, meds, and create EOSS as a function
#
# Description:
# The purpose of this script is break apart the visits_post_id data frame and 
# then process the visits data to utilize index date at control and intervention
# and last visit (excluding index visits) at control and intervention separately
# to capture labs, meds and create the EOSS. Needs four different data frames 
# with non-overlapping visits to work properly.
#
# Dependencies:
# labs_procedures.R
# medications.R
# eoss.r
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


proc_labs_meds_eoss <- function(data){
  # Load functions ---------------------------------------------------------------
  source(str_c(emr_dir, "subscripts/labs_procedures.R"))
  source(str_c(emr_dir, "subscripts/medications.R"))
  source(str_c(emr_dir, "subscripts/eoss.R"))
  
  # Create data subsets ----------------------------------------------------------
  # Make a copy of the output when processed in serial
  #visits_post_id_backup <- visits_post_id 
  # Revert visits_post_id back to its form before processing labs, meds, eoss
  
  ## 1. index visits in control phase ----
  # Can be processed normally without modifying the index date
  ind_con <- bind_rows(
    (data %>%
       filter(Censored == 0,
              IndexVisit == 1,
              Intervention == 0,
              LastVisit == 1)),
    (data %>%
       filter(Censored == 0,
              IndexVisit == 1,
              Intervention == 0,
              LastVisit == 0))
  )
  
  ## 2. last visits in control phase ----
  # Needs a temporary modification of the index date to trick the algorithm into
  # using the encounter date instead of the index date
  lv_con <- data %>%
    filter(Censored == 0,
           IndexVisit == 0,
           Intervention == 0,
           LastVisit == 1) %>%
    mutate(IndexDate_backup = IndexDate,
           IndexDate = EncounterDate,
           IndexVisit = 1) 
  
  ## 3. index visits in intervention phase ----
  # Can be processed normally without modifying the index date
  ind_int <- bind_rows(
    (data %>%
       filter(Censored == 0,
              IndexVisit == 1,
              Intervention == 1,
              LastVisit == 1)),
    (data %>%
       filter(Censored == 0,
              IndexVisit == 1,
              Intervention == 1,
              LastVisit == 0)))
  
  ## 4. last visits in intervention phase ----
  # Needs a temporary modification of the index date to trick the algorithm into
  # using the encounter date instead of the index date
  lv_int <- data %>%
    filter(Censored == 0,
           IndexVisit == 0,
           Intervention == 1,
           LastVisit == 1) %>%
    mutate(IndexDate_backup = IndexDate,
           IndexDate = EncounterDate,
           IndexVisit = 1) 
  
  # Put dfs into a list and then process -----------------------------------------
  df_list <- list(ind_con, lv_con, ind_int, lv_int)
  
  rm(ind_con, lv_con, ind_int, lv_int)
  
  # Set a function with the labs, meds, and eoss functions inside for use with the
  # lapply() function
  proc_data <- function(temp) {
    purrr::walk(
        .x  = c("procedure", "labs", "flowsheets", "referrals", "meds"),
        .f = read_pw_csv
        )

    temp <- labs_procedures(temp)
    temp <- capture_medications(temp)
    return(temp)
  }

  # Apply proc_data to each data frame in df_list
  # df_list <- map(df_list, proc_data)
  # Took 981.2 seconds (16 minutes) w out eoss
  # tic()
  # seq_test <- map(df_list, proc_data)
  # beepr::beep(sound = 2)
  # toc()
  
  # Testing to process in parallel
  # 347.59 seconds (6 minutes) w out eoss
  # This is the best implementation of this function
  # now just fix the eoss part without loading data frames
  # W eoss time is 546.59 second
  # eoss takes the longest, setting max size to 12gb
  plan(multisession, workers = 4)
  options(future.rng.onMisuse = "ignore",
          future.globals.maxSize = (8 * 1024^3)
          )
  
  df_list <-
  c(1,2,3,4) %>%
    future_map(~ df_list[[.x]] %>% proc_data(.))
  beepr::beep(sound = 2)
  
  # rm(procedure, labs, flowsheets, referrals, meds)

  invisible(gc())
  
  # process eoss separately
  proc_data <- function(temp) {
    purrr::walk(
      .x  = c("dx", "dxco", "meds"),
      .f = read_pw_csv
    )
    
    temp <- eoss(temp)
    
    return(temp)
  }
  
  tic()
  df_list <-
    c(1,2,3,4) %>%
    future_map(~ df_list[[.x]] %>% proc_data(.))
  beepr::beep(sound = 2)
  toc()
  
  
# Other option is to assign a group to each
# ind_con, ind_int, lv_con, lv_int data frame
# then stack them together instead of putting 
# them in a list. 
# df %>%
# split(.$group) %>%
# future_map_dfr(~proc_data(.))



  
  
  # Clean up data before stitching------------------------------------------------
  # Since the labs_procedures(), capture_medications(), and eoss() functions 
  # require an index date, data subsets that do not have an index visit are set
  # to 1 and the index date is set to the encounter date to "trick" the function
  # into working correctly. This chunk of code reverts the IndexVisit and 
  # IndexDate columns back to their original state. Only needed for lv_con and
  # lv_int subsets.
  clean_data <- function(temp){
    if(sum(grepl("IndexDate_backup", names(temp))) == 1){
      temp %<>%
        mutate(IndexDate = IndexDate_backup,
               IndexVisit = 0) %>%
        select(-IndexDate_backup)
    }
    return(temp)
  }
  
  # Apply the clean_data function to the list of data frames
  df_list <- map(df_list, clean_data)
  
  # Recreate visits_post_id ------------------------------------------------------
  # This vector represents the index visits and last visit encounter ids used
  # capture the variables. Used to create a data frame that does not contain
  # those encounter ids
  linked_visit_ids <- 
    bind_rows(df_list) %>% 
    pull(Arb_EncounterId)
  
  # Filter out visits that were processed from visits_post_id
  non_linked_visits <- 
    data %>%
    filter(!Arb_EncounterId %in% linked_visit_ids)
  
  # Bind the subsets of index and last visits that were processed
  linked_visits <- bind_rows(df_list)
  
  # Check to ensure that no new rows were added before replacing visits_post_id
  # If no new rows, then bind the subsets together and save as a new visits_post_id
  # data frame
  if (bind_rows(linked_visits, non_linked_visits) %>% nrow() == dim(data)[1]){
    temp_data <- bind_rows(linked_visits, non_linked_visits)
  } else {
    stop("The number of modified output visits does not equal the number of input visits!!! Review and revise code.")
    
  }
  
  # Clean up the O2CPAP, Referrals, and Bariatric surgery variables
  # data %>% select(O2CPAPBIPAP) %>% tbl_summary()
  
  # Those with NA should not be index visits
  # data %>%
  #   filter(is.na(O2CPAPBIPAP),
  #          Censored == 0) %>%
  #   select(IndexVisit) %>%
  #   tbl_summary()
  
  # Fill data so that the subsequent encounters have the O2CPAPBIPAP, Referrals,
  # and bariatric surgery variables
  # data %>%
  #   group_by(Arb_PersonId, Intervention.factor) %>%
  #   arrange(desc(Intervention)) %>%
  #   fill(O2CPAPBIPAP, .direction = "down") %>%
  #   ungroup() %>%
  #   filter(is.na(O2CPAPBIPAP))
  #   select(O2CPAPBIPAP) %>%
  #   tbl_summary()

    
  temp_data %<>%
    group_by(Arb_PersonId, Intervention.factor) %>%
    arrange(desc(Intervention)) %>%
    fill(names(. %>% select(O2CPAPBIPAP:Ref_WellnessClinic)), .direction = "down") %>%
    ungroup() %>%
    select(-Cohort_end_date)

  
  return(temp_data)
}
